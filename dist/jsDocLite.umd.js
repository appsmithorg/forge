!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).jsDocLite=t()}(this,(function(){"use strict";return{entryRegex:{function:/@(function|func|method)\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/gm,constant:/@(const|constant)\s+{(\w+)}\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/gm,module:/@module\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/gm},tagRegex:{params:/@(param|arg|argument)\s+{([\s\S]*?)}\s+([a-zA-Z_$][0-9a-zA-Z_$]*)\s*-([\s\S]*?)(?=@|$)/g,returns:/@(returns?|return)\s+{([\s\S]*?)}\s*-([\s\S]*?)(?=@|$)/g,async:/@async/g,example:/@example\s+([\s\S]*?)(?=@|$)/g,link:/@(link|doc)\s+([\s\S]*?)(?=@|$)/g},jsdocRegex:/\/\*\*([\s\S]*?)\*\//g,async parseFromUrl(e){const t=await this.fetchJsContent(e);return this.parse(t)},parse(e){const t=e.match(this.jsdocRegex)||[],n={modules:{},constants:{},functions:{}};return t.forEach((e=>{const t=this.cleanCommentBlock(e),s=this.parseComment(t);s&&s.entryName&&(n[s.entryType+"s"][s.entryName]=s)})),n},parseComment(e){let t=null,n=null,s=null;const r=e.match(/^(.+?)(?=@|$)/s),a=r?r[0].trim():null;if(Object.entries(this.entryRegex).forEach((([r,a])=>{a.lastIndex=0;const o=a.exec(e);if(o)switch(n=r,r){case"constant":s=o[2],t=o[3];break;case"module":t=o[1];break;default:t=o[2]}})),!t)return null;const o={entryType:n,entryName:t,description:a,...s?{dataType:s}:{}};for(const[t,n]of Object.entries(this.tagRegex)){const s=[...e.matchAll(n)];s.length&&(2===s[0].length?o[t]=s[0][1].trim():o[t]=s.map((e=>({type:e[2]?.trim(),name:e[3]?.trim(),description:e[4]?.trim()}))))}return o},cleanCommentBlock:e=>e=(e=e.replace(/\/\*\*|\*\//g,"").trim()).replace(/^\s*\*+/gm,"").trim(),async fetchJsContent(e){const t=await fetch(e);if(!t.ok)throw new Error(`Failed to fetch JS content from ${e}`);return t.text()}}}));
